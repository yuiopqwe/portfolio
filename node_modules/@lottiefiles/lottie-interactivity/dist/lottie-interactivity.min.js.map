{"version":3,"file":"lottie-interactivity.min.js","sources":["../src/lottie-interactivity.js"],"sourcesContent":["const DEFAULT_OPTIONS = {\n  player: 'lottie-player',\n};\nconst LOTTIE_PLAYER_NODE = 'LOTTIE-PLAYER';\nconst ERROR_PREFIX = '[lottieInteractivity]:';\n\n/**\n * LottieFiles interactivity for Lottie\n */\nexport class LottieInteractivity {\n  constructor({ actions, container, mode, player, ...options } = DEFAULT_OPTIONS) {\n    // Save the original player entered by user, used for interaction chaining / loading animations on the fly\n    this.enteredPlayer = player;\n\n    // Resolve lottie instance specified in player option\n    if (!(typeof player === 'object' && player.constructor.name === 'AnimationItem')) {\n      if (typeof player === 'string') {\n        const elem = document.querySelector(player);\n\n        if (elem && elem.nodeName === LOTTIE_PLAYER_NODE) {\n          player = elem.getLottie();\n        }\n      } else if (player instanceof HTMLElement && player.nodeName === LOTTIE_PLAYER_NODE) {\n        player = player.getLottie();\n      }\n\n      // Throw error no player instance has been successfully resolved\n      if (!player) {\n        let message = ERROR_PREFIX + \"Specified player:\" + player + \" is invalid.\";\n\n        throw new Error(message);\n      }\n    }\n\n    // Get the configured container element.\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n\n    // Use player wrapper as fallback if container couldn't be resolved.\n    if (!container) {\n      container = player.wrapper;\n    }\n\n    this.player = player;\n    this.loadedAnimation = this.player.path + this.player.fileName + \".json\";\n    this.attachedListeners = false;\n    this.container = container;\n    this.mode = mode;\n    this.actions = actions;\n    this.options = options;\n    this.assignedSegment = null;\n    this.scrolledAndPlayed = false;\n\n    // Interaction chaining\n    this.interactionIdx = 0;\n    this.oldInterctionIdx = 0;\n    this.clickCounter = 0;\n    this.playCounter = 0;\n    this.stateHandler = new Map();\n    this.transitionHandler = new Map();\n  }\n\n  getContainerVisibility() {\n    // Get the bounding box for the lottie player or container\n    const { top, height } = this.container.getBoundingClientRect();\n\n    // Calculate current view percentage\n    const current = window.innerHeight - top;\n    const max = window.innerHeight + height;\n    return current / max;\n  }\n\n  getContainerCursorPosition(cursorX, cursorY) {\n    const { top, left, width, height } = this.container.getBoundingClientRect();\n\n    const x = (cursorX - left) / width;\n    const y = (cursorY - top) / height;\n\n    return { x, y };\n  }\n\n  initScrollMode() {\n    this.player.stop();\n    window.addEventListener('scroll', this.#scrollHandler, true);\n  }\n\n  initCursorMode() {\n    // To have click and hover interaction, force to only have that type and single action\n    // If there are multiple actions, click and hover are ignored\n    if (this.actions &&\n      this.actions.length === 1) {\n      if (this.actions[0].type === \"click\") {\n        this.player.loop = false;\n        this.player.stop();\n        this.container.addEventListener('click', this.#clickHoverHandler);\n      } else if (this.actions[0].type === \"hover\") {\n        this.player.loop = false;\n        this.player.stop();\n        this.container.addEventListener('mouseenter', this.#clickHoverHandler);\n\n        // For mobile\n        this.container.addEventListener('touchstart', this.#clickHoverHandler, { passive: true });\n      } else if (this.actions[0].type === \"toggle\") {\n        this.player.loop = false;\n        this.player.stop();\n        this.container.addEventListener('click', this.#toggleHandler);\n      } else if (this.actions[0].type === \"hold\" || this.actions[0].type === \"pauseHold\") {\n        this.container.addEventListener('mouseenter', this.#holdTransitionEnter);\n        this.container.addEventListener('mouseleave', this.#holdTransitionLeave);\n\n        // For mobile\n        this.container.addEventListener('touchstart', this.#holdTransitionEnter, { passive: true });\n        this.container.addEventListener('touchend', this.#holdTransitionLeave, { passive: true });\n\n      } else if (this.actions[0].type === \"seek\") {\n        this.player.loop = true;\n        this.player.stop();\n        this.container.addEventListener('mousemove', this.#mousemoveHandler);\n        // For mobile\n        this.container.addEventListener('touchmove', this.#touchmoveHandler, { passive: false });\n        this.container.addEventListener('mouseout', this.#mouseoutHandler);\n      }\n    } else {\n      this.player.loop = true;\n      this.player.stop();\n      this.container.addEventListener('mousemove', this.#mousemoveHandler);\n      this.container.addEventListener('mouseleave', this.#mouseoutHandler);\n\n      // Init the animations that set states when the cursor is outside the container, so that they\n      // are visibly idle at the desired frame before first interaction with them\n      this.#cursorHandler(-1, -1);\n    }\n  }\n\n  initChainMode() {\n    this.#initInteractionMaps();\n    this.player.loop = false;\n    this.player.stop();\n    this.#chainedInteractionHandler({ ignorePath: false });\n  }\n\n  start() {\n    if (this.mode === 'scroll') {\n      if (this.player.isLoaded) {\n        this.initScrollMode();\n      } else {\n        this.player.addEventListener('DOMLoaded', () => {\n          this.initScrollMode();\n        });\n      }\n    } else if (this.mode === 'cursor') {\n      if (this.player.isLoaded) {\n        this.initCursorMode();\n      } else {\n        this.player.addEventListener('DOMLoaded', () => {\n          this.initCursorMode();\n        });\n      }\n    } else if (this.mode === 'chain') {\n      // When passing animation object to LI the player is already loaded\n      if (this.player.isLoaded) {\n        this.initChainMode();\n      } else {\n        this.player.addEventListener('DOMLoaded', () => {\n          this.initChainMode();\n        });\n      }\n    }\n  }\n\n  redefineOptions({ actions, container, mode, player, ...options }) {\n    this.stop();\n\n    // Save the original player entered by user, used for interaction chaining / loading animations on the fly\n    this.enteredPlayer = player;\n\n    // Resolve lottie instance specified in player option\n    if (!(typeof player === 'object' && player.constructor.name === 'AnimationItem')) {\n      if (typeof player === 'string') {\n        const elem = document.querySelector(player);\n\n        if (elem && elem.nodeName === LOTTIE_PLAYER_NODE) {\n          player = elem.getLottie();\n        }\n      } else if (player instanceof HTMLElement && player.nodeName === LOTTIE_PLAYER_NODE) {\n        player = player.getLottie();\n      }\n\n      // Throw error no player instance has been successfully resolved\n      if (!player) {\n        let message = ERROR_PREFIX + \"Specified player:\" + player + \" is invalid.\";\n\n        throw new Error(message, player);\n      }\n    }\n\n    // Get the configured container element.\n    if (typeof container === 'string') {\n      container = document.querySelector(container);\n    }\n\n    // Use player wrapper as fallback if container couldn't be resolved.\n    if (!container) {\n      container = player.wrapper;\n    }\n\n    this.player = player;\n    this.loadedAnimation = this.player.path + this.player.fileName + \".json\";\n    this.attachedListeners = false;\n    this.container = container;\n    this.mode = mode;\n    this.actions = actions;\n    this.options = options;\n    this.assignedSegment = null;\n    this.scrolledAndPlayed = false;\n\n    // Interaction chaining\n    this.interactionIdx = 0;\n    this.clickCounter = 0;\n    this.playCounter = 0;\n    this.holdStatus = null;\n    this.stateHandler = new Map();\n    this.transitionHandler = new Map();\n\n    this.start();\n  }\n\n  stop() {\n    if (this.mode === 'scroll') {\n      window.removeEventListener('scroll', this.#scrollHandler, true);\n    }\n\n    if (this.mode === 'cursor') {\n      this.container.removeEventListener('click', this.#clickHoverHandler);\n      this.container.removeEventListener('click', this.#toggleHandler);\n      this.container.removeEventListener('mouseenter', this.#clickHoverHandler);\n      this.container.removeEventListener('touchstart', this.#clickHoverHandler);\n      this.container.removeEventListener('touchmove', this.#touchmoveHandler);\n      this.container.removeEventListener('mousemove', this.#mousemoveHandler);\n      this.container.removeEventListener('mouseleave', this.#mouseoutHandler);\n      this.container.removeEventListener('touchstart', this.#holdTransitionEnter);\n      this.container.removeEventListener('touchend', this.#holdTransitionLeave);\n    }\n\n    if (this.mode === 'chain') {\n      this.container.removeEventListener('click', this.#clickHoverHandler);\n      this.container.removeEventListener('click', this.#clickHoverStateHandler);\n\n      this.container.removeEventListener('mouseenter', this.#clickHoverHandler);\n      this.container.removeEventListener('touchstart', this.#clickHoverHandler);\n      this.container.removeEventListener('touchmove', this.#touchmoveHandler);\n      this.container.removeEventListener('mouseenter', this.#clickHoverStateHandler);\n      this.container.removeEventListener('touchstart', this.#clickHoverStateHandler);\n      this.container.removeEventListener('mouseenter', this.#holdTransitionEnter);\n      this.container.removeEventListener('touchstart', this.#holdTransitionEnter);\n\n      this.container.removeEventListener('mouseleave', this.#holdTransitionLeave);\n      this.container.removeEventListener('mousemove', this.#mousemoveHandler);\n      this.container.removeEventListener('mouseout', this.#mouseoutHandler);\n      this.container.removeEventListener('touchend', this.#holdTransitionLeave);\n\n      if (this.player) {\n        try {\n          this.player.removeEventListener('loopComplete', this.#onCompleteHandler);\n          this.player.removeEventListener('complete', this.#onCompleteHandler);\n          this.player.removeEventListener('enterFrame', this.#cursorSyncHandler);\n          this.player.removeEventListener('enterFrame', this.#holdHandler);\n        } catch (e) {\n          // User deleted the player before calling stop()\n          // Ignore\n        }\n      }\n    }\n    if (this.player) {\n      this.player.destroy();\n      this.player = null;\n    }\n  }\n\n  /**\n   * [chain mode]\n   * Init the state and transitions maps containing all the state and transition methods used for interaction chaining\n   */\n  #initInteractionMaps = () => {\n    if (!this.player)\n      return;\n\n    let loopState = () => {\n      if (this.actions[this.interactionIdx].loop) {\n        this.player.loop = parseInt(this.actions[this.interactionIdx].loop) - 1;\n      } else {\n        this.player.loop = true;\n      }\n      this.player.autoplay = true;\n    }\n    let autoplayState = () => {\n      this.player.loop = false;\n      this.player.autoplay = true;\n    }\n    let clickState = () => {\n      this.player.loop = false;\n      this.player.autoplay = false;\n      this.container.addEventListener('click', this.#clickHoverStateHandler);\n    }\n    let hoverState = () => {\n      this.player.loop = false;\n      this.player.autoplay = false;\n      this.container.addEventListener('mouseenter', this.#clickHoverStateHandler);\n      // For mobile\n      this.container.addEventListener('touchstart', this.#clickHoverStateHandler, { passive: true });\n    }\n    let clickTransition = () => {\n      this.container.addEventListener('click', this.#clickHoverHandler);\n    }\n    let hoverTransition = () => {\n      this.container.addEventListener('mouseenter', this.#clickHoverHandler);\n      // For mobile\n      this.container.addEventListener('touchstart', this.#clickHoverHandler, { passive: true });\n    }\n    let holdTransition = () => {\n      this.player.addEventListener('enterFrame', this.#holdHandler);\n      this.container.addEventListener('mouseenter', this.#holdTransitionEnter);\n      this.container.addEventListener('mouseleave', this.#holdTransitionLeave);\n      // For mobile\n      this.container.addEventListener('touchstart', this.#holdTransitionEnter, { passive: true });\n      this.container.addEventListener('touchend', this.#holdTransitionLeave, { passive: true });\n    }\n    let holdState = () => {\n      this.container.addEventListener('mouseenter', this.#holdTransitionEnter);\n      this.container.addEventListener('mouseleave', this.#holdTransitionLeave);\n      // For mobile\n      this.container.addEventListener('touchstart', this.#holdTransitionEnter, { passive: true });\n      this.container.addEventListener('touchend', this.#holdTransitionLeave, { passive: true });\n    }\n    let repeatTransition = () => {\n      this.player.loop = true;\n      this.player.autoplay = true;\n      let handler = () => { this.#repeatTransition({ handler }) };\n      this.player.addEventListener('loopComplete', handler);\n    }\n    let onCompleteTransition = () => {\n      let state = this.actions[this.interactionIdx].state;\n\n      if (state === 'loop')\n        this.player.addEventListener('loopComplete', this.#onCompleteHandler);\n      else\n        this.player.addEventListener('complete', this.#onCompleteHandler);\n    }\n    let cursorSyncTransition = () => {\n      this.player.stop();\n      this.player.addEventListener('enterFrame', this.#cursorSyncHandler);\n      this.container.addEventListener('mousemove', this.#mousemoveHandler);\n      this.container.addEventListener('touchmove', this.#touchmoveHandler, { passive: false });\n      this.container.addEventListener('mouseout', this.#mouseoutHandler);\n    }\n    this.stateHandler.set('loop', loopState);\n    this.stateHandler.set('autoplay', autoplayState);\n    this.stateHandler.set('click', clickState);\n    this.stateHandler.set('hover', hoverState);\n    this.stateHandler.set('hold', holdState);\n    this.stateHandler.set('pauseHold', holdState);\n\n    this.transitionHandler.set('click', clickTransition);\n    this.transitionHandler.set('hover', hoverTransition);\n    this.transitionHandler.set('hold', holdTransition);\n    this.transitionHandler.set('pauseHold', holdTransition);\n    this.transitionHandler.set('repeat', repeatTransition);\n    this.transitionHandler.set('onComplete', onCompleteTransition);\n    this.transitionHandler.set('seek', cursorSyncTransition);\n  }\n\n  /**\n   * [chain mode]\n   * Handle hover state on chained interactions\n   */\n  #clickHoverStateHandler = () => {\n    let forceFlag = this.actions[this.interactionIdx].forceFlag;\n\n    if (!forceFlag && this.player.isPaused === true) {\n      this.#playSegmentHandler(true);\n    } else if (forceFlag) {\n      this.#playSegmentHandler(true);\n    }\n  }\n\n  // [cursor mode]\n  #toggleHandler = () => {\n    if (this.clickCounter === 0) {\n      this.player.play();\n      this.clickCounter++;\n    } else {\n      this.clickCounter++;\n      this.player.setDirection(this.player.playDirection * -1);\n      this.player.play();\n    }\n  }\n\n  /**\n   * [cursor + chain mode]\n   * Handle click and hover in both cursor and chain mode\n   */\n  #clickHoverHandler = () => {\n    let forceFlag = this.actions[this.interactionIdx].forceFlag;\n    let state = this.actions[this.interactionIdx].state;\n    let transition = this.actions[this.interactionIdx].transition;\n\n    // If we're in chain mode and the click or hover transition is used, otherwise just play the animation\n    if (this.mode === 'chain') {\n      // Check if there is a counter or not and make a transition\n      if (this.actions[this.interactionIdx].count) {\n        let clickLimit = parseInt(this.actions[this.interactionIdx].count);\n        if (this.clickCounter < clickLimit - 1) {\n          this.clickCounter += 1;\n          return;\n        }\n      }\n      // No click counter, so we remove the listeners and got to next interaction\n      this.clickCounter = 0;\n      // Transition when the animation has finished playing\n      if (!forceFlag && (transition === \"click\" && state === \"click\") || (transition === \"hover\" && state === \"hover\"))\n        this.transitionHandler.get(\"onComplete\").call();\n      else\n        this.nextInteraction();\n      this.container.removeEventListener('click', this.#clickHoverHandler);\n      this.container.removeEventListener('mouseenter', this.#clickHoverHandler);\n      return;\n    }\n    // Using goToAndPlay rather than this.#playSegmentHandler(forceFlag) because we're in cursor mode\n    // there for we want to play from the beginning\n    if (!forceFlag && this.player.isPaused === true) {\n      this.player.goToAndPlay(0, true);\n    } else if (forceFlag) {\n      this.player.goToAndPlay(0, true);\n    }\n  }\n\n  // [cursor mode]\n  #mousemoveHandler = e => {\n    this.#cursorHandler(e.clientX, e.clientY);\n  };\n\n  // [cursor mode]\n  #touchmoveHandler = e => {\n    // Allows for syncing on Y axis without scrolling the page\n    if (e.cancelable)\n      e.preventDefault();\n    this.#cursorHandler(e.touches[0].clientX, e.touches[0].clientY);\n  };\n\n  // [cursor mode]\n  #mouseoutHandler = () => {\n    this.#cursorHandler(-1, -1);\n  };\n\n\n  /**\n   * [chain mode]\n   * Handle when a segment of the animation has finished playing\n   */\n  #onCompleteHandler = () => {\n    if (this.actions[this.interactionIdx].state === 'loop') {\n      this.player.removeEventListener('loopComplete', this.#onCompleteHandler);\n    } else {\n      this.player.removeEventListener('complete', this.#onCompleteHandler);\n    }\n    this.nextInteraction();\n  }\n\n  // [chain mode]\n  #repeatTransition = ({ handler }) => {\n    let repeatAmount = 1;\n\n    if (this.actions[this.interactionIdx].repeat)\n      repeatAmount = this.actions[this.interactionIdx].repeat;\n    if (this.playCounter >= repeatAmount - 1) {\n      this.playCounter = 0;\n      this.player.removeEventListener('loopComplete', handler);\n      this.player.loop = false;\n      this.player.autoplay = false;\n      this.nextInteraction();\n    } else {\n      this.playCounter += 1;\n    }\n  }\n\n  /**\n   * [chain mode]\n   * TODO: How does this work with markers? Get marker duration?\n   */\n  #cursorSyncHandler = () => {\n    let frames = this.actions[this.interactionIdx].frames;\n\n    if (frames && this.player.currentFrame >= parseInt(frames[1]) - 1) {\n      this.player.removeEventListener('enterFrame', this.#cursorSyncHandler);\n      this.container.removeEventListener('mousemove', this.#mousemoveHandler);\n      this.container.removeEventListener('mouseout', this.#mouseoutHandler);\n      setTimeout(this.nextInteraction, 0);\n    }\n  }\n\n  /**\n   * [chain mode]\n   * TODO: How does this work with markers? Get marker duration?\n   *\n   * With the hold transition we can't use playSegment so we have to manually verify if\n   * The user held long enough and check if the current frame is within the segment limits\n   *\n   */\n  #holdHandler = () => {\n    let frames = this.actions[this.interactionIdx].frames;\n\n    if ((frames && this.player.currentFrame >= frames[1]) || (this.player.currentFrame >= this.player.totalFrames - 1)) {\n      this.player.removeEventListener('enterFrame', this.#holdHandler);\n      this.container.removeEventListener('mouseenter', this.#holdTransitionEnter);\n      this.container.removeEventListener('mouseleave', this.#holdTransitionLeave);\n      // For mobile\n      this.container.removeEventListener('touchstart', this.#holdTransitionEnter, { passive: true });\n      this.container.removeEventListener('touchend', this.#holdTransitionLeave, { passive: true });\n      this.player.pause();\n\n      this.holdStatus = false;\n      this.nextInteraction();\n    }\n    // Pause player so that reverse playback doesn't leave the set frame boundries\n    if (this.player.playDirection === -1 && frames && this.player.currentFrame < frames[0]) {\n      this.player.pause();\n    }\n  }\n\n  // [cursor + chain mode]\n  #holdTransitionEnter = () => {\n    // On first cursor enter needs check\n    if (this.player.playDirection === -1 || this.holdStatus === null || !this.holdStatus) {\n      this.player.setDirection(1);\n      this.player.play();\n      this.holdStatus = true;\n    }\n  }\n\n  // [cursor + chain mode]\n  #holdTransitionLeave = () => {\n    if (this.actions[this.interactionIdx].transition === \"hold\" ||\n      this.actions[this.interactionIdx].state === \"hold\" ||\n      this.actions[0].type === \"hold\") {\n      this.player.setDirection(-1);\n      this.player.play();\n    } else if (this.actions[this.interactionIdx].transition === \"pauseHold\" ||\n      this.actions[this.interactionIdx].state === \"pauseHold\" ||\n      this.actions[0].type === \"pauseHold\") {\n      this.player.pause();\n    }\n    this.holdStatus = false;\n  }\n\n  // [chain mode]\n  #clearStateListeners = () => {\n    this.container.removeEventListener('click', this.#clickHoverHandler);\n    this.container.removeEventListener('click', this.#clickHoverStateHandler);\n\n    this.container.removeEventListener('mouseenter', this.#clickHoverHandler);\n    this.container.removeEventListener('touchstart', this.#clickHoverHandler);\n    this.container.removeEventListener('touchmove', this.#touchmoveHandler);\n    this.container.removeEventListener('mouseenter', this.#clickHoverStateHandler);\n    this.container.removeEventListener('touchstart', this.#clickHoverStateHandler);\n    this.container.removeEventListener('mouseenter', this.#holdTransitionEnter);\n    this.container.removeEventListener('touchstart', this.#holdTransitionEnter);\n\n    this.container.removeEventListener('mouseleave', this.#holdTransitionLeave);\n    this.container.removeEventListener('mousemove', this.#mousemoveHandler);\n    this.container.removeEventListener('mouseout', this.#mouseoutHandler);\n    this.container.removeEventListener('touchend', this.#holdTransitionLeave);\n\n    if (this.player) {\n      try {\n        this.player.removeEventListener('loopComplete', this.#onCompleteHandler);\n        this.player.removeEventListener('complete', this.#onCompleteHandler);\n        this.player.removeEventListener('enterFrame', this.#cursorSyncHandler);\n        this.player.removeEventListener('enterFrame', this.#holdHandler);\n      } catch (e) {\n        // User deleted the player before calling stop()\n        // Ignore\n      }\n    }\n  }\n\n  jumpToInteraction = (index) => {\n    this.#clearStateListeners();\n    this.interactionIdx = index;\n    this.interactionIdx < 0 ? this.interactionIdx = 0 : this.interactionIdx;\n    this.nextInteraction(false);\n  }\n\n  // [chain mode]\n  nextInteraction = (incrementIndex = true) => {\n    this.oldInterctionIdx = this.interactionIdx;\n    // If state is hover or click we need to remove listeners\n    this.#clearStateListeners();\n    this.player.loop = false;\n\n    // Check if theres a jump-to before incrementing\n    let jumpToIndex = this.actions[this.interactionIdx].jumpTo;\n    if (jumpToIndex) {\n      // If jumpToIndex is inside action length jump to it otherwise go to first action\n      if (jumpToIndex >= 0 && jumpToIndex < this.actions.length) {\n        this.interactionIdx = jumpToIndex;\n        this.#chainedInteractionHandler({ ignorePath: false });\n      } else {\n        this.interactionIdx = 0;\n        this.player.goToAndStop(0, true);\n        this.#chainedInteractionHandler({ ignorePath: false });\n      }\n    } else {\n      // Go to next interaction\n      if (incrementIndex)\n        this.interactionIdx++;\n      if (this.interactionIdx >= this.actions.length) {\n        // Go back to the first interaction\n        if (this.actions[this.actions.length - 1].reset) {\n          this.interactionIdx = 0;\n          this.player.resetSegments(true);\n          if (this.actions[this.interactionIdx].frames)\n            this.player.goToAndStop(this.actions[this.interactionIdx].frames, true);\n          else\n            this.player.goToAndStop(0, true);\n          this.#chainedInteractionHandler({ ignorePath: false });\n        }\n        else {\n          this.interactionIdx = this.actions.length - 1;\n          this.#chainedInteractionHandler({ ignorePath: false });\n        }\n      } else {\n        this.#chainedInteractionHandler({ ignorePath: false });\n      }\n    }\n\n    // Emit event from the lottie-player element\n    this.container.dispatchEvent(new CustomEvent(\"transition\", {\n      bubbles: true,\n      composed: true,\n      detail: { oldIndex: this.oldInterctionIdx, newIndex: this.interactionIdx }\n    }));\n  }\n\n  /**\n   * [chain mode]\n   * Checks if frames are an array or string, and calls appropriate method to play animation\n   */\n  #playSegmentHandler = (forceFlag) => {\n    let frames = this.actions[this.interactionIdx].frames;\n\n    //If no frame segment is defined, play the whole animation\n    if (!frames) {\n      this.player.resetSegments(true);\n      this.player.goToAndPlay(0, true);\n      return;\n    }\n    // If using named markers\n    if (typeof frames === 'string') {\n      this.player.goToAndPlay(frames, forceFlag);\n    } else {\n      this.player.playSegments(frames, forceFlag);\n    }\n  }\n\n  /**\n   * [chain mode]\n   * Load a new animation using the path defined in the current interaction\n   */\n  #loadAnimationInChain = () => {\n    let path = this.actions[this.interactionIdx].path;\n\n    // The animation path declared on the lottie-player was saved in the constructor under 'enteredPlayer'\n    // We assume that the path on the lottie-player element is the animation to use in the first action\n    if (!path) {\n      // If we passed animationData to Lottie-Interactivity, load the animation data otherwise use the path\n      if (typeof this.enteredPlayer === 'object' && this.enteredPlayer.constructor.name === 'AnimationItem') {\n        path = this.enteredPlayer;\n\n        if (this.player === path) {\n          this.#chainedInteractionHandler({ ignorePath: true });\n          return;\n        }\n      } else {\n        path = this.loadedAnimation;\n        let fileName = path.substr(path.lastIndexOf('/') + 1);\n        fileName = fileName.substr(0, fileName.lastIndexOf('.json'));\n\n        // Prevents reloading animation the same animation\n        if (this.player.fileName === fileName) {\n          this.#chainedInteractionHandler({ ignorePath: true });\n          return;\n        }\n      }\n    }\n\n    // Force width and height on the container to retain its size while the next animation is being loaded\n    let lottieContainerSize = this.container.getBoundingClientRect();\n    let newContainerStyle = \"width: \" + lottieContainerSize.width + \"px !important; height: \" +\n      lottieContainerSize.height + \"px !important; background: \" + this.container.style.background;\n    this.container.setAttribute('style', newContainerStyle);\n\n    if (!(typeof this.enteredPlayer === 'object' && this.enteredPlayer.constructor.name === 'AnimationItem')) {\n      if (typeof this.enteredPlayer === 'string') {\n        const elem = document.querySelector(this.enteredPlayer);\n\n        if (elem && elem.nodeName === LOTTIE_PLAYER_NODE) {\n          // Prevents adding the listeners multiple times if multiple animations are needed to be loaded from actions\n          if (!this.attachedListeners) {\n            // Remove the styling that prevents flickering\n            elem.addEventListener(\"ready\", () => {\n              this.container.style.width = '';\n              this.container.style.height = '';\n            });\n            elem.addEventListener(\"load\", () => {\n              this.player = elem.getLottie();\n              this.#chainedInteractionHandler({ ignorePath: true });\n            });\n            this.attachedListeners = true;\n          }\n          // The LottieFiles player destroys the animation when a new one is Loaded\n          elem.load(path);\n        }\n      } else if (this.enteredPlayer instanceof HTMLElement && this.enteredPlayer.nodeName === LOTTIE_PLAYER_NODE) {\n        // Prevents adding the listeners multiple times if multiple animations are needed to be loaded from actions\n        if (!this.attachedListeners) {\n          // Remove the styling that prevents flickering\n          this.enteredPlayer.addEventListener(\"ready\", () => {\n            this.container.style.width = '';\n            this.container.style.height = '';\n          });\n          this.enteredPlayer.addEventListener(\"load\", () => {\n            this.player = this.enteredPlayer.getLottie();\n            this.#chainedInteractionHandler({ ignorePath: true });\n          });\n          this.attachedListeners = true;\n        }\n        // The LottieFiles player destroys the animation when a new one is Loaded\n        this.enteredPlayer.load(path);\n      }\n      // Throw error no player instance has been successfully resolved\n      if (!this.player) {\n        throw new Error(`${ERROR_PREFIX} Specified player is invalid.`, this.enteredPlayer);\n      }\n    } else {\n      if (window.lottie) {\n        this.stop();\n        // Removes svg animation contained inside\n        this.container.innerHTML = \"\";\n\n        if (typeof path === 'object' && path.constructor.name === 'AnimationItem') {\n          this.player = window.lottie.loadAnimation({\n            loop: false,\n            autoplay: false,\n            animationData: path.animationData,\n            container: this.container\n          });\n        }\n        else {\n          this.player = window.lottie.loadAnimation({\n            loop: false,\n            autoplay: false,\n            path,\n            container: this.container\n          });\n        }\n\n        this.player.addEventListener('DOMLoaded', () => {\n          // Remove the styling that prevents flickering\n          this.container.style.width = '';\n          this.container.style.height = '';\n          this.#chainedInteractionHandler({ ignorePath: true });\n        });\n      } else {\n        throw new Error(`${ERROR_PREFIX} A Lottie player is required.`);\n      }\n    }\n    // Reset counters\n    this.clickCounter = 0;\n    this.playCounter = 0;\n  }\n\n  /**\n   * [chain mode]\n   * Check the action object at the current interaction index and set the needed interaction listeners as well\n   * as any extra options\n   */\n  #chainedInteractionHandler = ({ ignorePath }) => {\n    let frames = this.actions[this.interactionIdx].frames;\n    let state = this.actions[this.interactionIdx].state;\n    let transition = this.actions[this.interactionIdx].transition;\n    let path = this.actions[this.interactionIdx].path;\n    let stateFunction = this.stateHandler.get(state);\n    let transitionFunction = this.transitionHandler.get(transition);\n    let speed = this.actions[this.interactionIdx].speed ? this.actions[this.interactionIdx].speed : 1;\n    let delay = this.actions[this.interactionIdx].delay ? this.actions[this.interactionIdx].delay : 0;\n\n    // Check if path is detected or that we are at the beginning again and reset\n    // If we are back at the first action, we need to reload the animation declared on the lottie-player element\n    if (!ignorePath && (path || (this.actions[this.actions.length - 1].reset && this.interactionIdx === 0))) {\n      this.#loadAnimationInChain();\n      return;\n    }\n    setTimeout(() => {\n      if (frames) {\n        this.player.autoplay = false;\n        this.player.resetSegments(true);\n        this.player.goToAndStop(frames[0], true);\n      }\n      if (stateFunction) {\n        stateFunction.call();\n      } else if (state === \"none\") {\n        this.player.loop = false;\n        this.player.autoplay = false;\n      }\n      if (transitionFunction) {\n        transitionFunction.call();\n      }\n      if (this.player.autoplay) {\n        this.player.resetSegments(true);\n        this.#playSegmentHandler(true);\n      }\n      this.player.setSpeed(speed);\n    }, delay);\n  }\n\n  // [cursor mode]\n  #cursorHandler = (x, y) => {\n    // Resolve cursor position if cursor is inside container\n    if (x !== -1 && y !== -1) {\n      // Get container cursor position\n      const pos = this.getContainerCursorPosition(x, y);\n\n      // Use the resolved position\n      x = pos.x;\n      y = pos.y;\n    }\n\n    // Find the first action that satisfies the current position conditions\n    const action = this.actions.find(({ position }) => {\n      if (position) {\n        if (Array.isArray(position.x) && Array.isArray(position.y)) {\n          return x >= position.x[0] && x <= position.x[1] && y >= position.y[0] && y <= position.y[1];\n        } else if (!Number.isNaN(position.x) && !Number.isNaN(position.y)) {\n          return x === position.x && y === position.y;\n        }\n      }\n\n      return false;\n    });\n\n    // Skip if no matching action was found!\n    if (!action) {\n      return;\n    }\n\n    // Process action types:\n    if (action.type === 'seek' || action.transition === 'seek') {\n      // Seek: Go to a frame based on player scroll position action\n      const xPercent = (x - action.position.x[0]) / (action.position.x[1] - action.position.x[0]);\n      const yPercent = (y - action.position.y[0]) / (action.position.y[1] - action.position.y[0]);\n\n      this.player.playSegments(action.frames, true);\n\n      if (action.position.y[0] < 0 && action.position.y[1] > 1) {\n        this.player.goToAndStop(Math.floor(xPercent * this.player.totalFrames), true);\n      } else {\n        this.player.goToAndStop(Math.ceil(((xPercent + yPercent) / 2) * this.player.totalFrames), true);\n      }\n    } else if (action.type === 'loop') {\n      this.player.playSegments(action.frames, true);\n    } else if (action.type === 'play') {\n      // Play: Reset segments and continue playing full animation from current position\n      if (this.player.isPaused === true) {\n        this.player.resetSegments();\n      }\n      this.player.playSegments(action.frames);\n    } else if (action.type === 'stop') {\n      this.player.resetSegments(true);\n      // Stop: Stop playback\n      this.player.goToAndStop(action.frames[0], true);\n    }\n  };\n\n  // [scroll mode]\n  #scrollHandler = () => {\n    // Get container visibility percentage\n    const currentPercent = this.getContainerVisibility();\n\n    // Find the first action that satisfies the current position conditions\n    const action = this.actions.find(\n      ({ visibility }) => currentPercent >= visibility[0] && currentPercent <= visibility[1],\n    );\n\n    // Skip if no matching action was found!\n    if (!action) {\n      return;\n    }\n\n    // Process action types:\n    if (action.type === 'seek') {\n      // Seek: Go to a frame based on player scroll position action\n      const start = action.frames[0];\n      const end = action.frames.length == 2 ? action.frames[1] : (this.player.totalFrames - 1);\n\n      // Use global frame reference for frames within the seek section.\n      // Without this, if you follow a seek with a loop and then scroll back up,\n      // it will treat frame numbers as relative to the loop.\n      if (this.assignedSegment !== null) {\n        this.player.resetSegments(true);\n        this.assignedSegment = null;\n      }\n\n      this.player.goToAndStop(\n        start + Math.round(\n          ((currentPercent - action.visibility[0]) / (action.visibility[1] - action.visibility[0])) *\n          (end - start)\n        ),\n        true,\n      );\n    } else if (action.type === 'loop') {\n      this.player.loop = true;\n      // Loop: Loop a given frames\n      if (this.assignedSegment === null) {\n        // if not playing any segments currently. play those segments and save to state\n        this.player.playSegments(action.frames, true);\n        this.assignedSegment = action.frames;\n      } else {\n        // if playing any segments currently.\n        //check if segments in state are equal to the frames selected by action\n        if (this.assignedSegment !== action.frames) {\n          // if they are not equal. new segments are to be loaded\n          this.player.playSegments(action.frames, true);\n          this.assignedSegment = action.frames;\n        } else {\n          // if they are equal the play method must be called only if lottie is paused\n          if (this.player.isPaused === true) {\n            this.player.playSegments(action.frames, true);\n            this.assignedSegment = action.frames;\n          }\n        }\n      }\n    } else if (action.type === 'play' || action.type === 'playOnce') {\n      // Play: Reset segments and continue playing full animation from current position\n      if (action.type === 'playOnce' && !this.scrolledAndPlayed) {\n        this.scrolledAndPlayed = true;\n        this.player.resetSegments(true);\n        if (action.frames) {\n          this.player.playSegments(action.frames, true);\n        } else {\n          this.player.play();\n        }\n        return;\n      } else if (action.type === 'play' && this.player.isPaused) {\n        this.player.resetSegments(true);\n        if (action.frames) {\n          this.player.playSegments(action.frames, true);\n        } else {\n          this.player.play();\n        }\n      }\n    } else if (action.type === 'stop') {\n      // Stop: Stop playback\n      this.player.goToAndStop(action.frames[0], true);\n    }\n  };\n}\n\nexport const create = options => {\n  const instance = new LottieInteractivity(options);\n  instance.start();\n\n  return instance;\n};\n\nexport default create;\n"],"names":["DEFAULT_OPTIONS","player","ERROR_PREFIX","LottieInteractivity","actions","container","mode","options","_this","holdTransition","addEventListener","passive","holdState","stateHandler","set","interactionIdx","loop","parseInt","autoplay","transitionHandler","handler","state","stop","forceFlag","isPaused","clickCounter","play","setDirection","playDirection","transition","count","clickLimit","get","call","nextInteraction","removeEventListener","goToAndPlay","e","clientX","clientY","cancelable","preventDefault","touches","repeatAmount","repeat","playCounter","frames","currentFrame","setTimeout","totalFrames","pause","holdStatus","type","index","incrementIndex","oldInterctionIdx","jumpToIndex","jumpTo","length","ignorePath","goToAndStop","reset","resetSegments","dispatchEvent","CustomEvent","bubbles","composed","detail","oldIndex","newIndex","playSegments","path","_typeof","enteredPlayer","constructor","name","fileName","loadedAnimation","substr","lastIndexOf","lottieContainerSize","getBoundingClientRect","newContainerStyle","width","height","style","background","setAttribute","elem","document","querySelector","nodeName","attachedListeners","getLottie","load","HTMLElement","Error","window","lottie","innerHTML","loadAnimation","animationData","stateFunction","transitionFunction","speed","delay","setSpeed","x","y","pos","getContainerCursorPosition","action","find","position","Array","isArray","Number","isNaN","xPercent","yPercent","Math","floor","ceil","currentPercent","getContainerVisibility","visibility","start","end","assignedSegment","round","scrolledAndPlayed","message","wrapper","this","Map","top","innerHeight","cursorX","cursorY","left","isLoaded","initScrollMode","_this2","initCursorMode","initChainMode","destroy","create","instance"],"mappings":"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"}